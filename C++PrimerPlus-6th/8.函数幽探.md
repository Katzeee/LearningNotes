title: 函数幽探
date: 2021-04-03 14:29

---
### 内联函数p253

- 内联函数
    - 常规函数与内联函数采取不同的方式被编译器组合到程序中
    - 常规函数在运行时采取跳转到指令地址的方式
    - 内联函数则使用函数代码替换代码调用，也就是不需要指令跳转
    - 运行速度更快，但会占用更多内存，因为多次调用同一个内联函数将会产生多个副本
- 使用
    - 在函数声明前加上关键字 inline
    
    - 在函数定义前加上关键字 inline  
    
    - **内联函数不能递归**
    
    - 如果函数定义占多行，则将其作为内联函数就不太合适，也就是内联函数一般只用一行定义
    
      ```c++
      inline double square(double x) {return x*x;}
      ```
    
    - 相比于宏定义，内联函数可以传递表达式，如传 a-- 给宏定义会导致 a 被减两次

---

### 引用变量p255

- 使用
    - 相比于指针，引用必须在声明将其初始化，更类似于 const 指针
    
        ```c++
        int &rodents = rats;
        int *const pr = &rats;
        ```
    
    - rodents 扮演的角色和*pr 相同
    
    - 可以通过初始化来设置引用，无法通过赋值改变引用
    
    - 常量引用 const double &a 相传引用但是又不想改变值
    
    - 传递引用的限制更严格，如果在函数中要改变引用的值则无法传入表达式 p261
    
    - 当实参与引用不匹配时将生成临时变量，**仅当参数为 const 引用时**p262
        - 实参类型正确但不是左值
            - 左值：左值参数是可以被引用的数据对象，非左值包括字面常量和包含多项的表达式
        - 实参类型不正确但可以转换为正确类型
        
    - **尽可能将引用形参声明为 const**
    
    - 引用非常适合结构体和类
    
    - 基类引用指向子类对象
    
- 函数返回引用 p266
    - 可以作为引用参数传递给别的函数，同时也可以进行赋值
    - 注意不要返回不存在的内存单元的引用，如子函数中的局部变量，可以采取两种方法解决
        - 返回一个作为参数传进来的引用
        - new 一个新的储存空间，但可能会忘记回收，这就需要智能指针
    - 如果想要引用返回值，又不希望可以为其赋值，可以返回 const 引用
---
### 默认参数p274    

- 使用
    - 必须通过函数原型来设置默认值（也就是头文件下面的声明）
    - 必须从右向左添加默认值
    - 实参从左到右依次被赋给形参，不能有跳过

---

### 函数重载

- 函数重载
  
    - 允许定义名称相同的函数，条件是**特征标**不同
- 使用
    - 需要在函数调用中传递正确的参数类型，不然编译器将报错
    - 类型引用和类型本身是为同一个特征标 int a 和int &a 一样，无法完成重载
    - 发生多匹配时，调用最匹配的版本
    - 能不重载就不重载
- 名称修饰：内部用于区分同名函数

---

### 函数模板p281

- 使用范型来定义函数，将类型通过参数传给模板

    ```c++
    template<typename/class T>
    ```

- 有时可能需要重载运算符，另一种解决办法就是为**特定类型**提供**具体化模板**

- 显示具体化
    - 非模板函数
    
      ```c++
      void swap(job &, job &);
      ```
    
    - 函数模板
    
      ```c++
      template<typename T>
      void swap(T &, T &);
      ```
    
    - 具体化
    
      ```c++
      template <> void swap<job>(job &, job &);
      ```
    
    - **非模板**优于**显示具体化**优于**模板**
    
- 实例化与具体化
    - 编译器使用模板为特定类型生成函数定义时，得到的是模板实例 instance

    - 模板并非函数定义，但使用 int 的模板实例是函数定义，这种实例方法称为**隐式实例化**，由编译器自动完成

    - 显示实例化：命令编译器直接创建特定的实例

        ``` c++
        template void swap<int>(int &, int &)
        template void add<int>(int, int)
        ```

    - 显示具体化的声明如下，以下两种方式等价

        ```c++
        template <> void swap<int>(int &, int &)
        template <> void swap(int &, int &)
        ```

    - 显示具体化必须有自己的函数定义，而实例化不需要

    - 在传入参数类型不同时，如`int`和`double`，此时便可以用显示实例化 `swap<double>(x, m)`来将 int 转为 double 以匹配模板

    - **注意**如原模板传入的是引用参数，则`swap<double>(x, m)`没有用，因为`double &`无法应用`int`型参数 p289

- 重载解析 p289
    - 第一步：创建候选函数列表
    - 找到所有同名函数
    - 第二步：使用后选函数列表创建可行函数列表
    - 找到所有能够接受参数的函数**注意整数类型不能被隐式的转换为指针类型**
    - 第三步：确定是否有**最佳**可行函数，最佳匹配顺序如下
        - 1、完全匹配，常规函数优先于模板
        - 2、提升转换（char 和 shorts 自动转为 int，float 自动转换为 double）
        - 3、标准转换（int 转换为 char，long 转换为 double）
        - 4、用户定义的转换，如类声明中定义的转换
    - 若有两个完全匹配则是错误，**例外**允许最佳匹配情况 p291
        - const 和非 const 修饰指针或引用数据满足最佳匹配（注意修饰一般数据不构成完全匹配，将会报错）
        - 非模板函数与模板函数满足最佳匹配
        - **部分排序规则**
    
- 关键字 decltype
    - 用于定义变量类型 decltype(expression) z; 按顺序核对 z 的类型

    - 若 expression 是一个没有用括号括起的标识符，则 z 与标识符类型相同

    - 若 expression 是一个函数调用，与函数返回值类型相同**并不会实际调用该函数**

    - 若 expression 为一个左值，则 z 为指向其类型的引用

        ```c++
        double xx = 4.4;
        decltype ((xx)) z; //z is double &
        ```

     - 若以上条件都不满足，则 z 与 expression 的类型相同

         ```c++
         decltype(100L) z; //z is long
         ```

 - c++后置返回类型

     ```c++
     template<typename T1, typename T2>
     auto h(T1 x, T2 y) -> decltype(x + y)
     ```

